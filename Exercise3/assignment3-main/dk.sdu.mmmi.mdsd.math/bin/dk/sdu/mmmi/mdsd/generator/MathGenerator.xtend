/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.External
import dk.sdu.mmmi.mdsd.math.Par
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.ExternalUse

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(Program).next
		
		val math = program.mathExp
			
		//val result = math.compute
		
			
		fsa.generateFile(program.name + ".java",program.generateProgramCode
			
		)
		
		//This is more annoying than helpful
		//result.displayPanel
		
	}
		
	def CharSequence generateProgramCode(Program program)
	'''
		package math_expression;
		public class «program.name»{
			«FOR variable: program.mathExp.variables»
			«variable.generateVariableInstantions»
			«ENDFOR»
			
			«IF program.external.size != 0»
			private External external;
									  
			public «program.name»(External external) {
				this.external = external;
			}
			
			«ELSE»
			public «program.name»() {}
			«ENDIF»
			public void compute() {
		    «FOR variable: program.mathExp.variables»
		   	«variable.generateVariableCode(variable.name)»
		    «ENDFOR»
			}
			«IF program.external.size != 0»
			public interface External {
				«FOR external: program.external»
			    «external.generateExternalCode»
			    «ENDFOR»
			}
			«ENDIF»
		}
		
	'''
		
	def CharSequence generateExternalCode(External external)
	'''
	int «external.name»(«IF external.argumentLeft !== null»«external.argumentLeft» n«FOR argument: external.argumentsRight»,«argument» m«ENDFOR»«ENDIF»);
	
	'''
		
	def dispatch CharSequence generateVariableCode(VarBinding binding,String name)
	'''
	«IF binding.expression.isTypeLetBinding»
	«binding.expression.generateVariableCode(binding.name)»
	«ELSE»
	«binding.name» = «binding.expression.generateVariableCode(binding.name)»;
	«ENDIF»
	
	'''
		
	def boolean getIsTypeLetBinding(Expression expression)
	{
		return expression instanceof LetBinding
	}
		

	
	def dispatch CharSequence generateVariableCode(MathNumber exp,String name)
	'''«exp.value»'''
				
	def dispatch CharSequence generateVariableCode(Plus exp,String name)
	'''«exp.left.generateVariableCode(name)» + «exp.right.generateVariableCode(name)»'''

	def dispatch CharSequence generateVariableCode(Minus exp,String name)
	'''«exp.left.generateVariableCode(name)» - «exp.right.generateVariableCode(name)»'''
	
	def dispatch CharSequence generateVariableCode(Mult exp,String name)
	'''«exp.left.generateVariableCode(name)» * «exp.right.generateVariableCode(name)»'''
	
	def dispatch CharSequence generateVariableCode(Div exp,String name)
	'''«exp.left.generateVariableCode(name)» / «exp.right.generateVariableCode(name)»'''
	
	def dispatch CharSequence generateVariableCode(Par exp,String name)
	'''(«exp.exp.generateVariableCode(name)»)'''
				
	def dispatch CharSequence generateVariableCode(VariableUse exp,String name)
	'''«exp.ref.name»'''
	
	def dispatch CharSequence generateVariableCode(LetBinding exp,String name)
	'''
	{
		int «exp.name» = «IF exp.binding.thisCheck»this.«ENDIF»«exp.binding.generateVariableCode(name)»;
		«name» = «exp.body.generateVariableCode(exp.name)»;
	}
	'''
		
		def boolean thisCheck(Expression expression){
			if(expression instanceof Plus)
			{
				var exp = expression as Plus
				return exp.left instanceof VariableUse
			}
			
			if(expression instanceof Minus)
			{
				var exp = expression as Minus
				return exp.left instanceof VariableUse
			}
			
			if(expression instanceof Div)
			{
				var exp = expression as Div
				return exp.left instanceof VariableUse
			}
			
			if(expression instanceof Mult)
			{
				var exp = expression as Mult
				return exp.left instanceof VariableUse
			}
			return false
		}
	
	def dispatch CharSequence generateVariableCode(ExternalUse exp,String name)
	'''this.external.«exp.name»(«IF exp.argumentLeft !== null»«exp.argumentLeft.generateVariableCode(name)»«FOR arg: exp.argumentsRight»,«arg.generateVariableCode(name)»«ENDFOR»«ENDIF»)'''
			
			
			
			
			
			
			
			
				
	
		
				
	def CharSequence generateVariableInstantions(VarBinding binding)
	'''
		public int «binding.name»;
	'''
		
		
		
		
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def static compute(MathExp math) {
		variables = new HashMap()
		for(varBinding: math.variables)
			varBinding.computeExpression()
		variables
	}
	
	def static dispatch int computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
	
	def static dispatch int computeExpression(MathNumber exp) {
		exp.value
	}

	def static dispatch int computeExpression(Plus exp) {
		exp.left.computeExpression + exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Minus exp) {
		exp.left.computeExpression - exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Mult exp) {
		exp.left.computeExpression * exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Div exp) {
		exp.left.computeExpression / exp.right.computeExpression
	}

	def static dispatch int computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch int computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch int computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.name)
	}
	
	def static dispatch int computeBinding(LetBinding binding){
		binding.binding.computeExpression
	}
	
}
