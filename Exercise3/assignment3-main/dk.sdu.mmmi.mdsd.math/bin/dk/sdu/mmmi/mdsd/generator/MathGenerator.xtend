/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.External
import dk.sdu.mmmi.mdsd.math.Par
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.ExternalUse

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(Program).next
				
		//Generate file
		fsa.generateFile(program.name + ".java",program.generateProgramCode)		
	}
		
	def CharSequence generateProgramCode(Program program)
	'''
		package math_expression;
		public class «program.name»{
			«FOR variable: program.mathExp.variables»
			«variable.generateVariableInstantions»
			«ENDFOR»
			
			«IF program.external.size != 0»
			private External external;
									  
			public «program.name»(External external) {
				this.external = external;
			}
			
			«ELSE»
			public «program.name»() {}
			«ENDIF»
			public void compute() {
		    «FOR variable: program.mathExp.variables»
		   	«variable.generateVariableCode(variable.name)»
		    «ENDFOR»
			}
			«IF program.external.size != 0»
			public interface External {
				«FOR external: program.external»
			    «external.generateExternalCode»
			    «ENDFOR»
			}
			«ENDIF»
		}
		
	'''
		
	//A bit of a meh solution since it would give an error if an external has more than 2 arguments.
	//That being said a easy solution would be to create an array of letters [n,m...ect] and then use those in a loop but I'm a bit lazy atm
	def CharSequence generateExternalCode(External external)
	'''
	int «external.name»(«IF external.argumentLeft !== null»«external.argumentLeft» n«FOR argument: external.argumentsRight»,«argument» m«ENDFOR»«ENDIF»);
	
	'''
	
	//For all expressions doing something like
	//x = exp works
	//But for let doing that would give a weird result using my style:
	//x = {
	//exp
	//}
	//which is illegal in java
	//so if it is an let I need to do something else
	//{
	// int var = exp
	//	x = var
	//}
	//To do that I created a letbinding method that takes the var varibale for use further down the code.
	//But it does not solve nested let and im not 100% sure how to do that.
	//Maybe by adding a letbinding check in the letbinding?
	def dispatch CharSequence generateVariableCode(VarBinding binding,String name)
	'''
	«IF binding.expression.isTypeLetBinding»
	«binding.expression.generateVariableCode(binding.name)»
	«ELSE»
	«binding.name» = «binding.expression.generateVariableCode(binding.name)»;
	«ENDIF»
	'''
		
	def boolean getIsTypeLetBinding(Expression expression)
	{
		return expression instanceof LetBinding
	}
		
	def dispatch CharSequence generateVariableCode(MathNumber exp,String name)
	'''«exp.value»'''
				
	def dispatch CharSequence generateVariableCode(Plus exp,String name)
	'''«exp.left.generateVariableCode(name)» + «exp.right.generateVariableCode(name)»'''

	def dispatch CharSequence generateVariableCode(Minus exp,String name)
	'''«exp.left.generateVariableCode(name)» - «exp.right.generateVariableCode(name)»'''
	
	def dispatch CharSequence generateVariableCode(Mult exp,String name)
	'''«exp.left.generateVariableCode(name)» * «exp.right.generateVariableCode(name)»'''
	
	def dispatch CharSequence generateVariableCode(Div exp,String name)
	'''«exp.left.generateVariableCode(name)» / «exp.right.generateVariableCode(name)»'''
	
	def dispatch CharSequence generateVariableCode(Par exp,String name)
	'''(«exp.exp.generateVariableCode(name)»)'''
				
	def dispatch CharSequence generateVariableCode(VariableUse exp,String name)
	'''«exp.ref.name»'''
	
	def dispatch CharSequence generateVariableCode(LetBinding exp,String name)
	'''
	{
		int «exp.name» = «IF exp.binding.thisCheck»this.«ENDIF»«exp.binding.generateVariableCode(name)»;
		«name» = «exp.body.generateVariableCode(exp.name)»;
	}
	'''
		
	def boolean thisCheck(Expression expression){
		if(expression instanceof Plus)
		{
			var exp = expression as Plus
			return exp.left instanceof VariableUse
		}
		
		if(expression instanceof Minus)
		{
			var exp = expression as Minus
			return exp.left instanceof VariableUse
		}
		
		if(expression instanceof Div)
		{
		var exp = expression as Div
			return exp.left instanceof VariableUse
		}
			
		if(expression instanceof Mult)
		{
			var exp = expression as Mult
			return exp.left instanceof VariableUse
		}
		return false
	}
	
	def dispatch CharSequence generateVariableCode(ExternalUse exp,String name)
	'''this.external.«exp.name»(«IF exp.argumentLeft !== null»«exp.argumentLeft.generateVariableCode(name)»«FOR arg: exp.argumentsRight»,«arg.generateVariableCode(name)»«ENDFOR»«ENDIF»)'''
					
	def CharSequence generateVariableInstantions(VarBinding binding)
	'''
		public int «binding.name»;
	'''
}
