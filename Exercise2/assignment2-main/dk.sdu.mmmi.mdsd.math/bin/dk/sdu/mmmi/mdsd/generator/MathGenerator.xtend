/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Num
import dk.sdu.mmmi.mdsd.math.Par
import dk.sdu.mmmi.mdsd.math.Let
import dk.sdu.mmmi.mdsd.math.Var
import dk.sdu.mmmi.mdsd.math.OneMath

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	static Map<String, Integer> letVariables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		
		result.displayPanel
	}
	
	def static compute(MathExp mathExp) { 
	
		for(OneMath math : mathExp.mathExp)
		{
			var value = math.exp.computeExp()
			var name = math.name	
			variables.put(name,value)
			letVariables.clear()
		}
			
		variables
	}
	
	//This seems to work, I feel like recursion would work better 
	//than manually doing it in the let switch, but It works ¯\_(ツ)_/¯
	def static int computeExp(Expression exp) {
		switch exp {
			Plus: exp.left.computeExp()+exp.right.computeExp()
			Minus: exp.left.computeExp()-exp.right.computeExp()
			Mult: exp.left.computeExp()*exp.right.computeExp()
			Div: exp.left.computeExp()/exp.right.computeExp()
			Num: exp.value
			Par: exp.exp.computeExp()
			Var: {
				//Make sure to check the letVaribles first 
				//so if we have an var x and a let x it should look at the let x first (shadowing)
				if(letVariables.get(exp.id) !== null)
					letVariables.get(exp.id)
				
				else if(variables.get(exp.id) !== null)
					variables.get(exp.id)
						
				}
			Let: {
				
				var binding = exp.bind.computeExp()
				letVariables.put(exp.^var,binding)
				
				switch exp.body{
					Plus: exp.body.computeExp()
					Minus: exp.body.computeExp()
					Mult: exp.body.computeExp()
					Div: exp.body.computeExp()
					default: binding
				}
			}	
			default: throw new Exception("Should not get down here")		
		}
	}


	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}

}
